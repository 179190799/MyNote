# Java基础知识
1. JDK安装路径下的文件路径包含的内容：
	bin:该路径下存放了JDK的各种工具命令，常用的javac,java等命令就放在该路径下。
	db:该路径是安装Java	DB的路径。
	demo:该路径下存放了JDK提供的演示带代码，初学者可以参考这些演示代码。
	jre:该路径下安装的就是运行Java程序所需要的JRE环境。
	lib:该路径下存放的是JDK工具命令的实际执行程序。
	sample:该路径下存放了JDK提供的一些简单示例代码，初学者可以参考这些示例代码。
	src.zip:该压缩文件里存放的就是Java所以核心类库的源代码。
	README和LICE等说明性文档。

2. 什么是环境变量：
	环境变量通常是指在操作系统当中，用来指定系统运行时需要的一些参数。环境变量通常为一系列的键值对。

3. PATH环境变量的作用：
	Path环境变量是操作系统外部命令搜索路径。

4. CLASSPATH环境变量的作用：
	CLASSPATH环境变量是类文件搜索路径。

5. 什么是JRE：
	JRE是Java Runtime Environment,即Java运行环境，包括：Java虚拟机。Java平台核心类文件，其他支持文件。

6. Java的数据类型：
![Java数据类型](http://7xq2jk.com1.z0.glb.clouddn.com/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

7. Java中的**“=”**不是等号，而是赋值号，将赋值号右边的值赋值给赋值号左边的变量。

8. 变量的命名规范：
	1.变量命名语法规范：
		1.应该以字母、下划线或者$开头；
		2.后面跟字母、下划线、$或者是数字；
		3.Java变量名没有长度限制；
		4.Java变量名对大小写敏感
	2.驼峰命名法：
		1.变量名应该用有意义的英文单词；
		2.变量名如果只有一个单词，则所有的字母小写；
		3.变量名如果由多个英文单词组成，则从第二个单词开始首字母大写。

9. Java当中的运算符
	算术运算符：+，-，*，/，%，++，-- 。
	关系运算符：>  ，  < , >= ， <= ， == ， ！= 。
	布尔逻辑运算符：！，&，|，^ ， && ，|| 。
![逻辑运算符](http://7xq2jk.com1.z0.glb.clouddn.com/1.png)
	位运算符：& ， | ， ^ , ~ , >> , << , >>> 。
	赋值运算符：= 。
	扩展运算符：+= ， -= ，*= ， /= 。
	字符串连接运算符： + 。

10. i++和++i的区别是什么？ 
	i++和++i都是把i的值加1
	i++是先将i的值进行运算，然后再加1。
	++i是先将i的值加1，再进行运算。

11. 重载的定义：
	1.两个或者多个函数在同一个类当中；
	2.函数名相同；
	3.参数列表不同。

12. 构造方法：
	使用new+构造方法创建一个新的对象；
	没有返回值，名字必须和类名相同；
	作用是用来生成对象；
	构造方法是定义在Java类中的一个用来初始化对象的方法；
	没有构造方法时，系统会自动添加无参构造方法，有就不会添加。
	构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。
	构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值。

13. 继承：
	在面向对象的世界当中，继承就是一个类得到另一个类当中的成员变量和成员方法。
	在Java中只支持**单继承**，不允许多继承。即一个子类只允许继承一个父类。
	private修饰的属性是无法继承的。
	**继承的初始化顺序：**
	  1.初始化父类再初始化子类
	  2.先执行初始化对象中的属性，再执行构造方法中的初始化。
	**final关键字：**
	  final可以修饰类，方法，属性和变量；
	  finally修饰类，则该类不允许被继承；
	  final修饰方法，则该方法不允许被重写；
	  final修饰属性，则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（只能选其一);
	  fianl修饰变量，则改变量的值只能赋一次值即变为常量。
	**super的应用：**
	  子类的构造过程当中必须调用其父类的构造方法；
	  如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法；
	  如果显示的调用构造方法，必须在子类构造方法的第一行；
	  如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译出错。

14. 重写：
	override，也被称为覆盖或者重写。
	1.在具有父子关系的两个类当中
	2.父类和子类各有一个函数，这两个函数的定义（返回值型、函数名和参数列表）完全相同。

15. 接口的基本语法：
	1.使用interface定义；
	2.接口当中的方法都是抽象方法；
	3.接口当中的方法都是public权限；
	4.实现接口使用implements关键字；
	5.一个类可以实现多个接口；
	6.一个接口可以继承多个接口；
	7.接口中方法不能有方法体，同时方法的访问修饰符不能是 private 和 protected。

16. 判断方法虫重载的依据：
	1.必须在同一个类中；
	2.方法名相同；
	3.方法参数的个数、顺序或类型不同；
	4.与方法的修饰符或返回值没有关系。

17. 不容忽视的小陷阱：
	1.如果返回方法的返回类型为void，则方法中不能使用return返回值！
	2.方法的返回值最多只能有一个，不能返回多个值；
	3.方法返回值的类型必须兼容。

18. 成员变量和局部变量的区别：
	1.作用域不同：
	  局部变量的作用域仅限于定义它的方法；
	  成员变量的作用域在整个类内部都是可见的；
	2.初始值不同：
	  Java会给成员变量一个初始值；
	  Java不会给局部变量赋予初始值；
	3.在同一个方法中，不允许有同名局部变量；
	  在不同方法中，可以有同名局部变量；
	4.两类变量同名时，局部变量具有更高的优先级。

19. 静态变量：
	1.静态变量可以直接使用类名来访问，无需创建类的对象：
		类名.变量名
	2.使用对象名来访问静态变量：
		对象名.变量名
	3.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员；
	  如果希望在静态方法中调用非静态变量，可以通过创建类的对象，
	  然后通过对象来访问非静态变量
	4.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量；
	5.静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，
	  不能初始化普通的成员变量。
20. 封装：
	1.将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。
	2.封装的好处：
	  只能通过规定的方法访问数据；
	  隐藏类的实例细节，方便修改和实现。
	3.实现步骤：
	  1.修改属性的可见性；（设为private）
	  2.创建getter/setter方法；(用于属性的读写)
	  3.在getter/setter方法中加入属性控制语句。（对属性值的合法性进行判断）

21. 内部类：
	1.内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。
	2.作用：
	     1.内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类；
	     2.内部类的方法可以直接访问外部类的所有数据，包括私有的数据；
	     3.内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。
	3.种类：
	     1.成员内部类
         2.静态内部类
         3.方法内部类
         4.匿名内部类
    4.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，
      即：内部类 对象名 = 外部类对象.new 内部类( );
    5.注意：
    	 1.外部类是不能直接使用内部类的成员和方法。
    	 2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，
    	   如果要访问外部类的成员变量，可以使用 this 关键字。
    6.静态内部类是 static 修饰的内部类，
      这种内部类的特点是：
		1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问； 
		2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；
		  如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员；
		3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类();
	7.方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。
	  注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。

22. 多态：
	对象的多种形态
	1.引用多态：
	   父类的引用可以指向本类的对象；
	   父类的引用可以指向子类的对象；
	2.方法多态：
	  创建本类对象时，调用的方法为本类方法；
	  创建子类对象时，调用的方法为子类重写的方法或者继承的方法。

23. 抽象类：
	abstract定义抽象类；
	abstract定义抽象方法，只有声明，不需要实现；
	包含抽象方法的类是抽象类；
	抽象类中可以包含普通的方法，也可以没有抽象方法；
	抽象类不能直接创建，可以定义引用变量。

24. StringBuilder 类和 StringBuffer 类之间的区别：
	  StringBuffer是线程安全的,而StringBuilder则没有实现线程安全功能,所以性能略高。
	如何定义 StringBuilder 类的对象:
		StringBuilder str1 = new StringBuilder();
	  	//创建一个空的StringBuilder对象
	  	StringBuilder str2 = new StringBuilder("aaa");
	  	System.out.println(str2);

25. 基本类型转换为字符串有三种方法：
	1.使用包装类的 toString() 方法;
	2.使用String类的 valueOf() 方法;
	3.用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串;

26. Calendar 类的应用
		// 创建Canlendar对象
		Calendar c = Calendar.getInstance();        
		// 将Calendar对象转换为Date对象
		Date date = c.getTime();       
		// 创建SimpleDateFormat对象，指定目标格式
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");      
		// 将日期转换为指定格式的字符串
		String now = sdf.format(date);
		System.out.println("当前时间：" + now);

27. 集合的作用：
	在类的内部，对数据进行组织；
	简单而快速的搜索大数量的条目；
	有点集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素；
	有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型。
![JAVA集合框架](http://7xq2jk.com1.z0.glb.clouddn.com/JAVA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.png)
	Collection接口：
	  是List、Set和Queue接口的父接口；
	  定义了可用于操作List、Set和Queue的方法-----增删查改；

28. List接口及其实现类---ArrayList
	List是元素有序并且可以重复的集合，被称为序列；
	List可以精确的控制每个元素的插入位置，或删除某个位置元素。
	ArrayList----数组序列，是List的一个重要实现类；
	ArrayList底层是由数组实现的。

29. Set接口及其实现类----HsahSet
	Set是元素无序并且不可以重复的集合，被成为集；
	HashSet-----哈希集，是Set的一个重要实现类。

30. Map接口：
	Map提供了一种映射关系，其中的元素是以键值对的形式存储的，能够实现根据key快速查找value；
	Map中的键值对以Entry类型的对象实例形式存在；
	键不可重复，value值可以；
	每个键最大只能映射到一个值；
	Map接口提供了分别返回key值集合、value值集合以及Entry集合的方法；
	Map支持泛型，形式如:Map<K,V>。

31. HashMap类：
	HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现；
	HashMap中的Entry对象是无序排列的；
	Key和Value值都可以为null，但是一个HashMap只能有一个key值为null的映射（key值不可重复）。

32. Comparable接口------可比较的
	实现该接口表示：这个类的实例可以比较大小，可以进行自然排序；
	定义了默认的比较规则；
	其实现类需实现compare TO()方法；
	compare TO()方法返回正数表示大，负数表示小，0表示相等。

33. Comparator接口------比较工具接口
	用于定义临时比较规则，而不是默认比较规则；
	其实现类需要实现compare()方法；
	Comparator和Comparable都是Java集合框架的成员。

34. JAVA中的异常分为编译时异常即CheckedException和运行时异常RuntimeException.
    Checked异常处理方法有两种：

        - 当前方法知道如何处理该异常，则用try...catch块来处理该异常
        - 当前方法不知道如何处理，则在定义该方法时抛出该异常。
    运行时异常只有当代码在运行时才发生的异常，由系统自动检测并将他们交给缺省的异常处理程序。

35. Java中的几种类型的流：
    字节流和字符流。
    字节流继承于InputStream和OutputStream.
    字符流继承于InputStreamReader和OutputStreamWriter.

36. 字节流转为字符流：
    字节输入流转字符输入流通过InputStreamReader实现，该类的构造函数可以传入InputStream对象。
    字节输出流转字符输出流通过OutputStreamWriter实现，该类的构造函数可以传入OutputStream对象。

37. 在JAVA中wait和sleep方法的不同
    在等待时wait会释放锁，而sleep一直持有锁。
    wait通常被用于线程间交互，sleep通常被用于暂停执行。

38. synchronized和volatile关键字的作用
    一旦一个共享变量(类的成员变量，类的静态成员变量)被volatile修饰之后，就具备两层含义：
````
    - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
    - 禁止进行指令重排序。
````

    + volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的，需要从主存中读取；
    synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。
    + volatile仅能使用在变量级别；
    synchronized则可以使用在变量、方法和类级别。
    + volatile仅能实现变量的修改可见性，并不能保证原子性；
    synchronized则可以保证变量的修改可见性和原子性。
    + volatile不会造成线程阻塞；
    synchronized可能会造成线程的阻塞。
    + volatile标记的变量不会被编译器优化；
    synchronized标记的变量可以被编译器优化。

39. 什么是线程池
    线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用new线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高了代码的执行效率。
    在JDK的java.util.concurrent.Executors中提供了生成多种线程池的静态方法。

    - ExecutorService newCachedThreadPool = Executors.newCacheThreadPool();
    - ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);
    - ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);
    - ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();
    
    然后调用他们的execute()方法即可。

40. JAVA中的反射
    JAVA中的反射首先是能够获取到JAVA中要反射类的字节码，获取字节码又有三种方法：

    - Class.forName(className)
    - 类名.class
    - this.getClass()
    然后将字节码中的方法，变量，构造函数等映射成相应的Method，Field，Constructor等类，这些类提供了丰富的方法供开发者使用。

41. Java中的设计模式
    一般认为有23种设计模式，总体来说设计模式分为三大类。

    - 创建型模式：
    **工厂方法模式**
    **抽象工厂模式**
    **单例模式**
    **建造者模式**
    原型模式

    - 结构型模式：
    **适配器模式**
    装饰器模式
    **代理模式**
    外观模式
    桥接模式
    组合模式

    - 行为型模式
    **策略模式**
    模板方法模式
    **观察者模式**
    迭代子模式
    责任链模式
    命令模式
    备忘录模式
    状态模式
    访问者模式
    中介者模式
    解释权模式

42. 单例设计模式
    分为懒汉式和饿汉式。

    - 饿汉式
    ````java
    public class Singleton{
        //直接创建对象
        public static Singleton instance = new Singleton();

        //私有化构造函数
        private Singleton(){ }

        //返回对象实例
        public static Singleton getInstance(){
            return instance;
        }
    }
    ````
    - 懒汉式
    ````java
    public class Singleton{
        //声明变量
        private static volatile Singleton singleton2 = null;
        //私有构造函数
        private Singleton2(){ }

        //提供对外方法
        public static Singleton2 getInstance(){
            if(singleton2 == null){
                sychronized(Singleton2.class){
                    if(singleton == null){
                        singleton = new Singleton();
                    }
                 }
            }
            return singleton;
        }
    }
````
