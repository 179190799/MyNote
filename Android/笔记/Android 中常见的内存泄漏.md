# Android 中常见的内存泄漏
## Activity 对象未被回收
### 静态变量引用 Activity 对象
通过静态变量引用 Activity 对象时，会导致 Activity 对象所占内存泄漏。主要是因为静态变量是驻扎在 JVM 的方法区，因此，静态变量引用的对象是不会被 GC 回收的，因为它们所引用的对象本身就是 GC ROOT,即最终导致 Activity 对象不被回收，从而也就造成内存泄漏。
### 静态 View
有时，当一个Activity经常启动，但是对应的View读取非常耗时，我们可以通过静态View变量来保持对该Activity的rootView引用。这样就可以不用每次启动Activity都去读取并渲染View了。这确实是一个提高Activity启动速度的好方法！但是要注意，一旦View attach到我们的Window上，就会持有一个Context(即Activity)的引用。而我们的View是一个静态变量，所以导致Activity不被回收。因此在使用静态View时，需要确保在资源回收时，将静态View detach掉。
### 内部类
因为非静态内部类持有外部类的引用，所以如果我们在一个外部类中定义一个静态变量，这个静态变量是引用内部类对象，将会导致内存泄漏，因为这相当于间接导致静态类引用外部类。
### 匿名类
与内部类一样，匿名类也会持有外部类的引用
### Handler
如果在Activity中定义Handler对象，那么Handler肯定是持有Activty的引用。而每个Message对象是持有Handler的引用的（Message对象的target属性持有Handler引用），从而导致Message间接引用到了Activity。如果在Activty destroy之后，消息队列中还有Message对象，Activty是不会被回收的。当然，如果消息正在准备（处于延时入队期间）放入到消息队列中也是一样的。
解决办法就是，将Handler放入单独的类或者将Handler放入到静态内部类中（静态内部类不会持有外部类的引用）。如果想要在handler内部去调用所在的外部类Activity，可以在handler内部使用弱引用的方式指向所在Activity，这样不会导致内存泄漏。
### Threads和TimerTask
Threads和Timer导致内存泄漏的原因跟内部类一样。虽然在新的线程中创建匿名类，但是只要是匿名类/内部类，它都会持有外部类引用。
### 监听器
当我们需要使用系统服务时，比如执行某些后台任务、为硬件访问提供接口等等系统服务。我们需要把自己注册到服务的监听器中。然而，这会让服务持有 activity 的引用，如果程序员忘记在 activity 销毁时取消注册，那就会导致 activity 泄漏了。
## 集合对象造成的泄漏
当我们定义一个静态的集合类时，这可能会导致内存泄漏！静态变量所引用的对象是不会被回收掉的。而静态集合类中，包含有大量的对象，这些对象不会被回收。另外，如果集合中保存的对象又引用到了其他的大对象，如超长字符串、Bitmap、大数组等，很容易造成OOM。
## 资源对象没关闭造成内存泄漏
当打开资源时，一般都会使用缓存。比如读写文件资源、打开数据库资源、使用Bitmap资源等等。当我们不再使用时，应该关闭它们，使得缓存内存区域及时回收。
## 使用对象池避免频繁创建对象
在我们需要频繁创建使用某个类时，或者是在for循环里面创建新的对象时，导致JVM不断创建同一个类。